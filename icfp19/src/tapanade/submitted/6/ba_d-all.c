#ifdef __cplusplus
extern "C" {
#endif
/*        Generated by TAPENADE     (INRIA, Ecuador team)
    Tapenade 3.13 (r6666M) -  1 Mar 2018 15:30
*/
#include <stdlib.h>
#include <math.h>
#include <float.h>

/*
  Differentiation of sqsum in forward (tangent) mode:
   variations   of useful results: sqsum
   with respect to varying inputs: *x
   Plus diff mem management of: x:in
*/
// name of top routine:
// project
// dependent output variables:
// 
// independent variables:
// 
double sqsum_d(int n, double *x, double *xd, double *sqsum) {
    int i;
    double res;
    double resd;
    res = 0;
    resd = 0.0;
    for (i = 0; i < n; ++i) {
        resd = resd + xd[i]*x[i] + x[i]*xd[i];
        res = res + x[i]*x[i];
    }
    *sqsum = res;
    return resd;
}

/*
  Differentiation of cross in forward (tangent) mode:
   variations   of useful results: *out
   with respect to varying inputs: *a *b
   Plus diff mem management of: out:in a:in b:in
*/
void cross_d0(double *a, double *ad, double *b, double *bd, double *out, 
        double *outd) {
    outd[0] = ad[1]*b[2] + a[1]*bd[2] - ad[2]*b[1] - a[2]*bd[1];
    out[0] = a[1]*b[2] - a[2]*b[1];
    outd[1] = ad[2]*b[0] + a[2]*bd[0] - ad[0]*b[2] - a[0]*bd[2];
    out[1] = a[2]*b[0] - a[0]*b[2];
    outd[2] = ad[0]*b[1] + a[0]*bd[1] - ad[1]*b[0] - a[1]*bd[0];
    out[2] = a[0]*b[1] - a[1]*b[0];
}

/*
  Differentiation of rodrigues_rotate_point in forward (tangent) mode:
   variations   of useful results: *rotatedPt
   with respect to varying inputs: *rot *pt
   Plus diff mem management of: rot:in rotatedPt:in pt:in
*/
void rodrigues_rotate_point_d(double *rot, double *rotd, double *pt, double *
        ptd, double *rotatedPt, double *rotatedPtd) {
    int i;
    double sqtheta, theta, costheta, sintheta, theta_inverse, w[3], cross_[3]
    , tmp;
    double sqthetad, thetad, costhetad, sinthetad, theta_inversed, wd[3], 
    cross_d[3], tmpd;
    int ii1;
    sqthetad = sqsum_d(3, rot, rotd, &sqtheta);
    if (sqtheta != 0.) {
        thetad = (sqtheta == 0.0 ? 0.0 : sqthetad/(2.0*sqrt(sqtheta)));
        theta = sqrt(sqtheta);
        costhetad = -(thetad*sin(theta));
        costheta = cos(theta);
        sinthetad = thetad*cos(theta);
        sintheta = sin(theta);
        theta_inversed = -(thetad/(theta*theta));
        theta_inverse = 1.0/theta;
        for (ii1 = 0; ii1 < 3; ++ii1)
            wd[ii1] = 0.0;
        for (i = 0; i < 3; ++i) {
            wd[i] = rotd[i]*theta_inverse + rot[i]*theta_inversed;
            w[i] = rot[i]*theta_inverse;
        }
        cross_d0(w, wd, pt, ptd, cross_, cross_d);
        tmpd = (wd[0]*pt[0]+w[0]*ptd[0]+wd[1]*pt[1]+w[1]*ptd[1]+wd[2]*pt[2]+w[
            2]*ptd[2])*(1.-costheta) - (w[0]*pt[0]+w[1]*pt[1]+w[2]*pt[2])*
            costhetad;
        tmp = (w[0]*pt[0]+w[1]*pt[1]+w[2]*pt[2])*(1.-costheta);
        *rotatedPtd = 0.0;
        for (i = 0; i < 3; ++i) {
            rotatedPtd[i] = ptd[i]*costheta + pt[i]*costhetad + cross_d[i]*
                sintheta + cross_[i]*sinthetad + wd[i]*tmp + w[i]*tmpd;
            rotatedPt[i] = pt[i]*costheta + cross_[i]*sintheta + w[i]*tmp;
        }
    } else {
        cross_d0(rot, rotd, pt, ptd, cross_, cross_d);
        *rotatedPtd = 0.0;
        for (i = 0; i < 3; ++i) {
            rotatedPtd[i] = ptd[i] + cross_d[i];
            rotatedPt[i] = pt[i] + cross_[i];
        }
    }
}

/*
  Differentiation of radial_distort in forward (tangent) mode:
   variations   of useful results: *proj
   with respect to varying inputs: *rad_params *proj
   Plus diff mem management of: rad_params:in proj:in
*/
void radial_distort_d(double *rad_params, double *rad_paramsd, double *proj, 
        double *projd) {
    double rsq, L;
    double rsqd, Ld;
    rsqd = sqsum_d(2, proj, projd, &rsq);
    Ld = rad_paramsd[0]*rsq + rad_params[0]*rsqd + rad_paramsd[1]*(rsq*rsq) + 
        rad_params[1]*(rsqd*rsq+rsq*rsqd);
    L = 1 + rad_params[0]*rsq + rad_params[1]*rsq*rsq;
    projd[0] = projd[0]*L + proj[0]*Ld;
    proj[0] = proj[0]*L;
    projd[1] = projd[1]*L + proj[1]*Ld;
    proj[1] = proj[1]*L;
}

/*
  Differentiation of project in forward (tangent) mode:
   variations   of useful results: *proj
   with respect to varying inputs: *cam *X *proj
   RW status of diff variables: *cam:in *X:in *proj:in-out
   Plus diff mem management of: cam:in X:in proj:in
*/
void project_d(double *cam, double *camd, double *X, double *Xd, double *proj,
        double *projd) {
    int i;
    double *C;
    double *Cd;
    double Xo[3], Xcam[3];
    double Xod[3], Xcamd[3];
    int ii1;
    Cd = &camd[3];
    C = &cam[3];
    for (ii1 = 0; ii1 < 3; ++ii1)
        Xod[ii1] = 0.0;
    for (i = 0; i < 3; ++i) {
        Xod[i] = Xd[i] - Cd[i];
        Xo[i] = X[i] - C[i];
    }
    rodrigues_rotate_point_d(&cam[0], &camd[0], Xo, Xod, Xcam, Xcamd);
    projd[0] = (Xcamd[0]*Xcam[2]-Xcam[0]*Xcamd[2])/(Xcam[2]*Xcam[2]);
    proj[0] = Xcam[0]/Xcam[2];
    projd[1] = (Xcamd[1]*Xcam[2]-Xcam[1]*Xcamd[2])/(Xcam[2]*Xcam[2]);
    proj[1] = Xcam[1]/Xcam[2];
    radial_distort_d(&cam[9], &camd[9], proj, projd);
    for (i = 0; i < 2; ++i) {
        projd[i] = projd[i]*cam[6] + proj[i]*camd[6] + camd[7 + i];
        proj[i] = proj[i]*cam[6] + cam[7 + i];
    }
}
#ifdef __cplusplus
}
#endif