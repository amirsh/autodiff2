/*        Generated by TAPENADE     (INRIA, Ecuador team)
    Tapenade 3.13 (r6665M) - 27 Nov 2017 15:43
*/
#include <math.h>

/*
  Differentiation of arr_max in forward (tangent) mode:
   variations   of useful results: arr_max
   with respect to varying inputs: *x
   Plus diff mem management of: x:in
*/
double arr_max_d(int n, double *x, double *xd, double *arr_max) {
    double m;
    double md;
    int i;
    md = xd[0];
    m = x[0];
    for (i = 1; i < n; ++i)
        if (x[i] > m) {
            md = xd[i];
            m = x[i];
        }
    *arr_max = m;
    return md;
}

/*
  Differentiation of logsumexp in forward (tangent) mode:
   variations   of useful results: logsumexp
   with respect to varying inputs: *x
   Plus diff mem management of: x:in
*/
double logsumexp_d(int n, double *x, double *xd, double *logsumexp) {
    int i;
    double mx, semx;
    double mxd, semxd;
    mxd = arr_max_d(n, x, xd, &mx);
    semx = 0.;
    semxd = 0.0;
    for (i = 0; i < n; ++i) {
        semxd = semxd + (xd[i]-mxd)*exp(x[i]-mx);
        semx += exp(x[i] - mx);
    }
    *logsumexp = log(semx) + mx;
    return semxd/semx + mxd;
}

/*
  Differentiation of sqnorm in forward (tangent) mode:
   variations   of useful results: sqnorm
   with respect to varying inputs: *x
   Plus diff mem management of: x:in
*/
double sqnorm_d(int d, double *x, double *xd, double *sqnorm) {
    int i;
    double out;
    double outd;
    out = 0;
    outd = 0.0;
    for (i = 0; i < d; ++i) {
        outd = outd + xd[i]*x[i] + x[i]*xd[i];
        out += x[i]*x[i];
    }
    *sqnorm = out;
    return outd;
}

/*
  Differentiation of log_wishart_prior in forward (tangent) mode:
   variations   of useful results: log_wishart_prior
   with respect to varying inputs: *Qdiags *sum_qs *icf
   Plus diff mem management of: Qdiags:in sum_qs:in icf:in
*/
double log_wishart_prior_d(int p, int k, double wishart_gamma, double 
        wishart_m, double *sum_qs, double *sum_qsd, double *Qdiags, double *
        Qdiagsd, double *icf, double *icfd, double *log_wishart_prior) {
    int n, ik, icf_sz;
    double out, C, frobenius;
    double outd, frobeniusd;
    double result1;
    double result1d;
    double result2;
    double result2d;
    icf_sz = p*(p+1)/2;
    out = 0;
    outd = 0.0;
    for (ik = 0; ik < k; ++ik) {
        result1d = sqnorm_d(p, &Qdiags[ik*p], &Qdiagsd[ik*p], &result1);
        result2d = sqnorm_d(icf_sz - p, &icf[ik*icf_sz + p], &icfd[ik*icf_sz +
                            p], &result2);
        frobeniusd = result1d + result2d;
        frobenius = result1 + result2;
        outd = outd + 0.5*frobeniusd;
        out = out + 0.5*frobenius;
    }
    *log_wishart_prior = out;
    /* *wishart.gamma*wishart.gamma 
-wishart.m */
    // the last bit is here so that tapenade would recognize that means and inv_cov_factors are variables
    return outd;
}

/*
  Differentiation of preprocess_qs in forward (tangent) mode:
   variations   of useful results: *Qdiags *sum_qs
   with respect to varying inputs: *Qdiags *sum_qs *icf
   Plus diff mem management of: Qdiags:in sum_qs:in icf:in

 - k*C + (Qdiags[0] - Qdiags[0]) + (icf[0] - icf[0]) */
void preprocess_qs_d(int d, int k, double *icf, double *icfd, double *sum_qs, 
        double *sum_qsd, double *Qdiags, double *Qdiagsd) {
    int icf_sz, ik, id;
    double q;
    double qd;
    icf_sz = d*(d+1)/2;
    for (ik = 0; ik < k; ++ik) {
        sum_qsd[ik] = 0.0;
        sum_qs[ik] = 0.;
        for (id = 0; id < d; ++id) {
            qd = icfd[ik*icf_sz + id];
            q = icf[ik*icf_sz + id];
            sum_qsd[ik] = sum_qsd[ik] + qd;
            sum_qs[ik] += q;
            Qdiagsd[ik*d + id] = qd*exp(q);
            Qdiags[ik*d + id] = exp(q);
        }
    }
}

/*
  Differentiation of Qtimesx in forward (tangent) mode:
   variations   of useful results: *out
   with respect to varying inputs: *out *Qdiag *x *ltri
   Plus diff mem management of: out:in Qdiag:in x:in ltri:in
*/
void Qtimesx_d(int d, double *Qdiag, double *Qdiagd, double *ltri, double *
        ltrid, double *x, double *xd, double *out, double *outd) {
    // strictly lower triangular part
    int id, i, j, Lparamsidx;
    for (id = 0; id < d; ++id) {
        outd[id] = Qdiagd[id]*x[id] + Qdiag[id]*xd[id];
        out[id] = Qdiag[id]*x[id];
    }
    Lparamsidx = 0;
    for (i = 0; i < d; ++i)
        for (j = i+1; j < d; ++j) {
            outd[j] = outd[j] + ltrid[Lparamsidx]*x[i] + ltri[Lparamsidx]*xd[i
                ];
            out[j] = out[j] + ltri[Lparamsidx]*x[i];
            Lparamsidx = Lparamsidx + 1;
        }
}

/*
  Differentiation of subtract in forward (tangent) mode:
   variations   of useful results: *out
   with respect to varying inputs: *out *x *y
   Plus diff mem management of: out:in x:in y:in
*/
// out = a - b
void subtract_d(int d, double *x, double *xd, double *y, double *yd, double *
        out, double *outd) {
    int id;
    for (id = 0; id < d; ++id) {
        outd[id] = xd[id] - yd[id];
        out[id] = x[id] - y[id];
    }
}

/*
  Differentiation of gmm_objective in forward (tangent) mode:
   variations   of useful results: alloc(*Qxcentered) alloc(*xcentered)
                alloc(*Qdiags) alloc(*sum_qs) alloc(*main_term)
                *err
   with respect to varying inputs: alloc(*Qxcentered) alloc(*xcentered)
                alloc(*Qdiags) alloc(*sum_qs) alloc(*main_term)
                *err *x *means *icf *alphas
   RW status of diff variables: alloc(*Qxcentered):in-out alloc(*xcentered):in-out
                alloc(*Qdiags):in-out alloc(*sum_qs):in-out alloc(*main_term):in-out
                *err:in-out *x:in *means:in *icf:in *alphas:in
   Plus diff mem management of: err:in x:in means:in icf:in alphas:in
*/
void gmm_objective_d(int d, int k, int n, double *alphas, double *alphasd, 
        double *means, double *meansd, double *icf, double *icfd, double *x, 
        double *xd, double wishart_gamma, double wishart_m, double *err, 
        double *errd) {
    int ik, ix, icf_sz;
    double *main_term, *sum_qs, *Qdiags, *xcentered, *Qxcentered;
    double *main_termd, *sum_qsd, *Qdiagsd, *xcenteredd, *Qxcenteredd;
    double slse, lse_alphas, CONSTANT;
    double slsed, lse_alphasd;
    double result1;
    double result1d;
    int ii1;
    // CONSTANT = -n*d*0.5*log(2 * PI);
    icf_sz = d*(d+1)/2;
    main_termd = (double *)malloc(k*sizeof(double));
    for (ii1 = 0; ii1 < k; ++ii1)
        main_termd[ii1] = 0.0;
    main_term = (double *)malloc(k*sizeof(double));
    sum_qsd = (double *)malloc(k*sizeof(double));
    for (ii1 = 0; ii1 < k; ++ii1)
        sum_qsd[ii1] = 0.0;
    sum_qs = (double *)malloc(k*sizeof(double));
    Qdiagsd = (double *)malloc(d*k*sizeof(double));
    for (ii1 = 0; ii1 < d*k; ++ii1)
        Qdiagsd[ii1] = 0.0;
    Qdiags = (double *)malloc(d*k*sizeof(double));
    xcenteredd = (double *)malloc(d*sizeof(double));
    for (ii1 = 0; ii1 < d; ++ii1)
        xcenteredd[ii1] = 0.0;
    xcentered = (double *)malloc(d*sizeof(double));
    Qxcenteredd = (double *)malloc(d*sizeof(double));
    for (ii1 = 0; ii1 < d; ++ii1)
        Qxcenteredd[ii1] = 0.0;
    Qxcentered = (double *)malloc(d*sizeof(double));
    preprocess_qs_d(d, k, icf, icfd, sum_qs, sum_qsd, Qdiags, Qdiagsd);
    slse = 0.;
    slsed = 0.0;
    for (ix = 0; ix < n; ++ix) {
        for (ik = 0; ik < k; ++ik) {
            subtract_d(d, &x[ix*d], &xd[ix*d], &means[ik*d], &meansd[ik*d], 
                       xcentered, xcenteredd);
            Qtimesx_d(d, &Qdiags[ik*d], &Qdiagsd[ik*d], &icf[ik*icf_sz + d], &
                      icfd[ik*icf_sz + d], xcentered, xcenteredd, Qxcentered, 
                      Qxcenteredd);
            result1d = sqnorm_d(d, Qxcentered, Qxcenteredd, &result1);
            main_termd[ik] = alphasd[ik] + sum_qsd[ik] - 0.5*result1d;
            main_term[ik] = alphas[ik] + sum_qs[ik] - 0.5*result1;
        }
        result1d = logsumexp_d(k, main_term, main_termd, &result1);
        slsed = slsed + result1d;
        slse = slse + result1;
    }
    free(main_termd);
    free(main_term);
    free(xcenteredd);
    free(xcentered);
    free(Qxcenteredd);
    free(Qxcentered);
    lse_alphasd = logsumexp_d(k, alphas, alphasd, &lse_alphas);
    *errd = slsed - n*lse_alphasd;
    *err = slse - n*lse_alphas;
    /*CONSTANT + */
    result1d = log_wishart_prior_d(d, k, wishart_gamma, wishart_m, sum_qs, 
                                   sum_qsd, Qdiags, Qdiagsd, icf, icfd, &
                                   result1);
    *errd = *errd + result1d;
    *err = *err + result1;
    free(sum_qsd);
    free(sum_qs);
    free(Qdiagsd);
    free(Qdiags);
    // this is here so that tapenade would recognize that means and inv_cov_factors are variables
    *err = *err;
}
