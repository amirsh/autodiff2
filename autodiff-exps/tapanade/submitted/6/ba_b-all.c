#ifdef __cplusplus
extern "C" {
#endif
/*        Generated by TAPENADE     (INRIA, Ecuador team)
    Tapenade 3.13 (r6666M) -  1 Mar 2018 15:30
*/
#include "../../ADFirstAidKit/adBuffer.h"
#include <stdlib.h>
#include <math.h>
#include <float.h>
#include "ba_b-all.h"
#include "ba.h"

/*
  Differentiation of sqsum in reverse (adjoint) mode:
   gradient     of useful results: *x sqsum
   with respect to varying inputs: *x
   Plus diff mem management of: x:in
*/
// name of top routine:
// project
// dependent output variables:
// 
// independent variables:
// 
void sqsum_b(int n, double *x, double *xb, double sqsumb) {
    int i;
    double res;
    double resb;
    double sqsum;
    resb = sqsumb;
    for (i = n-1; i > -1; --i)
        xb[i] = xb[i] + 2*x[i]*resb;
}

/*
  Differentiation of cross in reverse (adjoint) mode:
   gradient     of useful results: *out *a *b
   with respect to varying inputs: *a *b
   Plus diff mem management of: out:in a:in b:in
*/
void cross_b0(double *a, double *ab, double *b, double *bb, double *out, 
        double *outb) {
    ab[0] = ab[0] + b[1]*outb[2];
    bb[1] = bb[1] + a[0]*outb[2];
    ab[1] = ab[1] - b[0]*outb[2];
    bb[0] = bb[0] - a[1]*outb[2];
    outb[2] = 0.0;
    ab[2] = ab[2] + b[0]*outb[1];
    bb[0] = bb[0] + a[2]*outb[1];
    ab[0] = ab[0] - b[2]*outb[1];
    bb[2] = bb[2] - a[0]*outb[1];
    outb[1] = 0.0;
    ab[1] = ab[1] + b[2]*outb[0];
    bb[2] = bb[2] + a[1]*outb[0];
    ab[2] = ab[2] - b[1]*outb[0];
    bb[1] = bb[1] - a[2]*outb[0];
}

/*
  Differentiation of rodrigues_rotate_point in reverse (adjoint) mode:
   gradient     of useful results: *rot *rotatedPt
   with respect to varying inputs: *rot *pt
   Plus diff mem management of: rot:in rotatedPt:in pt:in
*/
void rodrigues_rotate_point_b(double *rot, double *rotb, double *pt, double *
        ptb, double *rotatedPt, double *rotatedPtb) {
    int i;
    double sqtheta, theta, costheta, sintheta, theta_inverse, w[3], cross_[3]
    , tmp;
    double sqthetab, thetab, costhetab, sinthetab, theta_inverseb, wb[3], 
    cross_b[3], tmpb;
    double tempb;
    int ii1;
    sqtheta = sqsum(3, rot);
    if (sqtheta != 0.) {
        theta = sqrt(sqtheta);
        costheta = cos(theta);
        sintheta = sin(theta);
        theta_inverse = 1.0/theta;
        for (i = 0; i < 3; ++i)
            w[i] = rot[i]*theta_inverse;
        cross(w, pt, cross_);
        tmp = (w[0]*pt[0]+w[1]*pt[1]+w[2]*pt[2])*(1.-costheta);
        *ptb = 0.0;
        for (ii1 = 0; ii1 < 3; ++ii1)
            wb[ii1] = 0.0;
        for (ii1 = 0; ii1 < 3; ++ii1)
            cross_b[ii1] = 0.0;
        costhetab = 0.0;
        tmpb = 0.0;
        sinthetab = 0.0;
        for (i = 2; i > -1; --i) {
            ptb[i] = ptb[i] + costheta*rotatedPtb[i];
            costhetab = costhetab + pt[i]*rotatedPtb[i];
            cross_b[i] = cross_b[i] + sintheta*rotatedPtb[i];
            sinthetab = sinthetab + cross_[i]*rotatedPtb[i];
            wb[i] = wb[i] + tmp*rotatedPtb[i];
            tmpb = tmpb + w[i]*rotatedPtb[i];
            rotatedPtb[i] = 0.0;
        }
        tempb = (1.-costheta)*tmpb;
        wb[0] = wb[0] + pt[0]*tempb;
        ptb[0] = ptb[0] + w[0]*tempb;
        wb[1] = wb[1] + pt[1]*tempb;
        ptb[1] = ptb[1] + w[1]*tempb;
        wb[2] = wb[2] + pt[2]*tempb;
        ptb[2] = ptb[2] + w[2]*tempb;
        costhetab = costhetab - (w[0]*pt[0]+w[1]*pt[1]+w[2]*pt[2])*tmpb;
        cross_b0(w, wb, pt, ptb, cross_, cross_b);
        theta_inverseb = 0.0;
        for (i = 2; i > -1; --i) {
            rotb[i] = rotb[i] + theta_inverse*wb[i];
            theta_inverseb = theta_inverseb + rot[i]*wb[i];
            wb[i] = 0.0;
        }
        thetab = cos(theta)*sinthetab - sin(theta)*costhetab - theta_inverseb/
            (theta*theta);
        if (sqtheta == 0.0)
            sqthetab = 0.0;
        else
            sqthetab = thetab/(2.0*sqrt(sqtheta));
    } else {
        *ptb = 0.0;
        for (ii1 = 0; ii1 < 3; ++ii1)
            cross_b[ii1] = 0.0;
        for (i = 2; i > -1; --i) {
            ptb[i] = ptb[i] + rotatedPtb[i];
            cross_b[i] = cross_b[i] + rotatedPtb[i];
            rotatedPtb[i] = 0.0;
        }
        cross_b0(rot, rotb, pt, ptb, cross_, cross_b);
        sqthetab = 0.0;
    }
    sqsum_b(3, rot, rotb, sqthetab);
}

/*
  Differentiation of radial_distort in reverse (adjoint) mode:
   gradient     of useful results: *rad_params *proj
   with respect to varying inputs: *rad_params *proj
   Plus diff mem management of: rad_params:in proj:in
*/
void radial_distort_b(double *rad_params, double *rad_paramsb, double *proj, 
        double *projb) {
    double rsq, L;
    double rsqb, Lb;
    rsq = sqsum(2, proj);
    L = 1 + rad_params[0]*rsq + rad_params[1]*rsq*rsq;
    pushreal8(proj[0]);
    proj[0] = proj[0]*L;
    Lb = proj[1]*projb[1];
    projb[1] = L*projb[1];
    popreal8(&proj[0]);
    Lb = Lb + proj[0]*projb[0];
    projb[0] = L*projb[0];
    rad_paramsb[0] = rad_paramsb[0] + rsq*Lb;
    rsqb = (rad_params[1]*2*rsq+rad_params[0])*Lb;
    rad_paramsb[1] = rad_paramsb[1] + rsq*rsq*Lb;
    sqsum_b(2, proj, projb, rsqb);
}

/*
  Differentiation of project in reverse (adjoint) mode:
   gradient     of useful results: *proj
   with respect to varying inputs: *cam *X *proj
   RW status of diff variables: *cam:out *X:out *proj:in-out
   Plus diff mem management of: cam:in X:in proj:in
*/
void project_b(double *cam, double *camb, double *X, double *Xb, double *proj,
        double *projb) {
    int i;
    double *C;
    double *Cb;
    double Xo[3], Xcam[3];
    double Xob[3], Xcamb[3];
    int ii1;
    double tempb;
    double tempb0;
    Cb = &camb[3];
    C = &cam[3];
    for (i = 0; i < 3; ++i)
        Xo[i] = X[i] - C[i];
    rodrigues_rotate_point(&cam[0], Xo, Xcam);
    proj[0] = Xcam[0]/Xcam[2];
    proj[1] = Xcam[1]/Xcam[2];
    pushreal8(*proj);
    radial_distort(&cam[9], proj);
    for (i = 0; i < 2; ++i) {
        pushreal8(proj[i]);
        proj[i] = proj[i]*cam[6] + cam[7 + i];
    }
    *camb = 0.0;
    for (i = 1; i > -1; --i) {
        popreal8(&proj[i]);
        camb[6] = camb[6] + proj[i]*projb[i];
        camb[7 + i] = camb[7 + i] + projb[i];
        projb[i] = cam[6]*projb[i];
    }
    popreal8(proj);
    radial_distort_b(&cam[9], &camb[9], proj, projb);
    for (ii1 = 0; ii1 < 3; ++ii1)
        Xcamb[ii1] = 0.0;
    tempb = projb[1]/Xcam[2];
    Xcamb[1] = Xcamb[1] + tempb;
    Xcamb[2] = Xcamb[2] - Xcam[1]*tempb/Xcam[2];
    projb[1] = 0.0;
    tempb0 = projb[0]/Xcam[2];
    Xcamb[0] = Xcamb[0] + tempb0;
    Xcamb[2] = Xcamb[2] - Xcam[0]*tempb0/Xcam[2];
    projb[0] = 0.0;
    rodrigues_rotate_point_b(&cam[0], &camb[0], Xo, Xob, Xcam, Xcamb);
    *Xb = 0.0;
    for (i = 2; i > -1; --i) {
        Xb[i] = Xb[i] + Xob[i];
        Cb[i] = Cb[i] - Xob[i];
        Xob[i] = 0.0;
    }
}
#ifdef __cplusplus
}
#endif