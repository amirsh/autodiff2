#ifdef __cplusplus
extern "C" {
#endif
/*        Generated by TAPENADE     (INRIA, Ecuador team)
    Tapenade 3.13 (r6666M) -  1 Mar 2018 15:30
*/
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include "../../ADFirstAidKit/adBuffer.h"
#include "gmm_b-all.h"
#include "../../gmm.h"

/*
  Differentiation of arr_max in reverse (adjoint) mode:
   gradient     of useful results: *x arr_max
   with respect to varying inputs: *x
   Plus diff mem management of: x:in
*/
// name of top routine:
// gmm_objective
// dependent output variables:
// err
// independent variables:
// alphas
void arr_max_b(int n, double *x, double *xb, double arr_maxb) {
    double m;
    double mb;
    int i;
    int branch;
    double arr_max;
    m = x[0];
    for (i = 1; i < n; ++i)
        if (x[i] > m) {
            m = x[i];
            pushcontrol1b(1);
        } else
            pushcontrol1b(0);
    mb = arr_maxb;
    for (i = n-1; i > 0; --i) {
        popcontrol1b(&branch);
        if (branch != 0) {
            xb[i] = xb[i] + mb;
            mb = 0.0;
        }
    }
    xb[0] = xb[0] + mb;
}

/*
  Differentiation of logsumexp in reverse (adjoint) mode:
   gradient     of useful results: *x logsumexp
   with respect to varying inputs: *x
   Plus diff mem management of: x:in
*/
void logsumexp_b(int n, double *x, double *xb, double logsumexpb) {
    int i;
    double mx, semx;
    double mxb, semxb;
    double tempb;
    double logsumexp;
    mx = arr_max(n, x);
    semx = 0.;
    for (i = 0; i < n; ++i)
        semx = semx + exp(x[i] - mx);
    semxb = logsumexpb/semx;
    mxb = logsumexpb;
    for (i = n-1; i > -1; --i) {
        tempb = exp(x[i]-mx)*semxb;
        xb[i] = xb[i] + tempb;
        mxb = mxb - tempb;
    }
    arr_max_b(n, x, xb, mxb);
}

/*
  Differentiation of gmm_objective in reverse (adjoint) mode:
   gradient     of useful results: *err
   with respect to varying inputs: *err *alphas
   RW status of diff variables: *err:in-out *alphas:out
   Plus diff mem management of: err:in alphas:in
*/
void gmm_objective_b(int d, int k, int n, double *alphas, double *alphasb, 
        double *means, double *icf, double *x, double wishart_gamma, double 
        wishart_m, double *err, double *errb) {
    int ik, ix, icf_sz;
    double *main_term, *sum_qs, *Qdiags, *xcentered, *Qxcentered;
    double *main_termb;
    double slse, lse_alphas, CONSTANT;
    double slseb, lse_alphasb;
    double result1;
    double result1b;
    int ii1;
    // CONSTANT = -n*d*0.5*log(2 * PI);
    main_termb = (double *)malloc(k*sizeof(double));
    for (ii1 = 0; ii1 < k; ++ii1)
        main_termb[ii1] = 0.0;
    main_term = (double *)malloc(k*sizeof(double));
    sum_qs = (double *)malloc(k*sizeof(double));
    Qdiags = (double *)malloc(d*k*sizeof(double));
    xcentered = (double *)malloc(d*sizeof(double));
    Qxcentered = (double *)malloc(d*sizeof(double));
    preprocess_qs(d, k, icf, sum_qs, Qdiags);
    for (ix = 0; ix < n; ++ix)
        for (ik = 0; ik < k; ++ik) {
            subtract(d, &x[ix*d], &means[ik*d], xcentered);
            Qtimesx(d, &Qdiags[ik*d], &icf[ik*icf_sz + d], xcentered, 
                    Qxcentered);
            result1 = sqnorm(d, Qxcentered);
            pushreal8(main_term[ik]);
            main_term[ik] = alphas[ik] + sum_qs[ik] - 0.5*result1;
        }
    slseb = *errb;
    lse_alphasb = -(n*(*errb));
    *errb = 0.0;
    *alphasb = 0.0;
    logsumexp_b(k, alphas, alphasb, lse_alphasb);
    for (ix = n-1; ix > -1; --ix) {
        result1b = slseb;
        logsumexp_b(k, main_term, main_termb, result1b);
        for (ik = k-1; ik > -1; --ik) {
            popreal8(&main_term[ik]);
            alphasb[ik] = alphasb[ik] + main_termb[ik];
            main_termb[ik] = 0.0;
        }
    }
    free(Qxcentered);
    free(xcentered);
    free(Qdiags);
    free(sum_qs);
    free(main_term);
    free(main_termb);
}
#ifdef __cplusplus
}
#endif