#include <math.h>
#include "micro.h"
/*        Generated by TAPENADE     (INRIA, Ecuador team)
    Tapenade 3.13 (r6666M) -  1 Mar 2018 15:30
*/
/*
  Differentiation of vec_add in reverse (adjoint) mode:
   gradient     of useful results: alloc(*res) *x
   with respect to varying inputs: alloc(*res) *x
   RW status of diff variables: alloc(*res):in-out *x:incr
   Plus diff mem management of: x:in
*/
void vec_add_b(int n, double *x, double *xb, double *y, double *vec_addb) {
    double *res;
    double *resb;
    int ii1;
    double *vec_add;
    resb = (double *)malloc(n*sizeof(double));
    for (ii1 = 0; ii1 < n; ++ii1)
        resb[ii1] = 0.0;
    res = (double *)malloc(n*sizeof(double));
    double* tmp = resb;
    resb = vec_addb;
    vec_addb = tmp;
    for (int i = n-1; i > -1; --i) {
        xb[i] = xb[i] + resb[i];
        resb[i] = 0.0;
    }
    free(res);
    free(vec_addb);
}
/*
  Differentiation of vec_elem_mult in reverse (adjoint) mode:
   gradient     of useful results: alloc(*res) *x *y
   with respect to varying inputs: alloc(*res) *x *y
   RW status of diff variables: alloc(*res):in-out *x:incr *y:incr
   Plus diff mem management of: x:in y:in
*/
void vec_elem_mult_b(int n, double *x, double *xb, double *y, double *yb, 
        double *vec_elem_multb) {
    double *res;
    double *resb;
    int ii1;
    double *vec_elem_mult;
    resb = (double *)malloc(n*sizeof(double));
    for (ii1 = 0; ii1 < n; ++ii1)
        resb[ii1] = 0.0;
    res = (double *)malloc(n*sizeof(double));
    resb = vec_elem_multb;
    vec_elem_multb = (void *)0;
    for (int i = n-1; i > -1; --i) {
        xb[i] = xb[i] + y[i]*resb[i];
        yb[i] = yb[i] + x[i]*resb[i];
        resb[i] = 0.0;
    }
    free(res);
    free(resb);
}

/*
  Differentiation of vec_scal_mult in reverse (adjoint) mode:
   gradient     of useful results: alloc(*res) y
   with respect to varying inputs: alloc(*res) y
   RW status of diff variables: alloc(*res):in-out y:incr
*/
void vec_scal_mult_b(int n, double *x, double y, double *yb, double *
        vec_scal_multb) {
    double *res;
    double *resb;
    int ii1;
    double *vec_scal_mult;
    // resb = (double *)malloc(n*sizeof(double));
    // for (ii1 = 0; ii1 < n; ++ii1)
    //     resb[ii1] = 0.0;
    res = (double *)malloc(n*sizeof(double));
    resb = vec_scal_multb;
    // vec_scal_multb = (void *)0;
    for (int i = n-1; i > -1; --i) {
        *yb = *yb + x[i]*2*y*resb[i];
        resb[i] = 0.0;
    }
    free(res);
    // free(resb);
}
/*
  Differentiation of vec_dot in reverse (adjoint) mode:
   gradient     of useful results: *x vec_dot
   with respect to varying inputs: *x
   RW status of diff variables: *x:incr vec_dot:in-killed
   Plus diff mem management of: x:in
*/
void vec_dot_b(int n, double *x, double *xb, double *y, double vec_dotb) {
    double res = 0;
    double resb = 0.0;
    double vec_dot;
    resb = vec_dotb;
    for (int i = n-1; i > -1; --i)
        xb[i] = xb[i] + y[i]*resb;
}
/*
  Differentiation of vec_max in reverse (adjoint) mode:
   gradient     of useful results: vec_max *v
   with respect to varying inputs: *v
   Plus diff mem management of: v:in
*/
void vec_max_b(int n, double *v, double *vb, double vec_maxb) {
    int x25608 = 0;
    double vec_max;
    for (int idx = 0; idx < n; ++idx) {
        int acc = x25608;
        int x25607;
        if (v[acc] > v[idx])
            x25607 = acc;
        else
            x25607 = idx;
        acc = x25607;
        x25608 = acc;
    }
    vb[x25608] = vb[x25608] + vec_maxb;
    for (int idx = n-1; idx > -1; --idx) {
        int acc = x25608;
        int x25607;
    }
}
/*
  Differentiation of vec_logsumexp in reverse (adjoint) mode:
   gradient     of useful results: *v vec_logsumexp
   with respect to varying inputs: *v
   RW status of diff variables: *v:incr vec_logsumexp:in-killed
   Plus diff mem management of: v:in
*/
void vec_logsumexp_b(int n, double *v, double *vb, double vec_logsumexpb) {
    double mx;
    double mxb;
    double vec_logsumexp;
    mx = vec_max(n, v);
    double x25609 = 0;
    double x25609b = 0.0;
    for (int idx = 0; idx < n; ++idx) {
        double acc = x25609;
        acc = acc + exp(v[idx] - mx);
        x25609 = acc;
    }
    x25609b = vec_logsumexpb/x25609;
    mxb = vec_logsumexpb;
    for (int idx = n-1; idx > -1; --idx) {
        double acc = x25609;
        double accb = 0.0;
        double tempb;
        accb = x25609b;
        tempb = exp(v[idx]-mx)*accb;
        vb[idx] = vb[idx] + tempb;
        mxb = mxb - tempb;
        x25609b = accb;
    }
    vec_max_b(n, v, vb, mxb);
}
/*
  Differentiation of vec_exp in reverse (adjoint) mode:
   gradient     of useful results: *res *v
   with respect to varying inputs: *res *v
   Plus diff mem management of: res:in v:in
*/
void vec_exp_b(int n, double *v, double *vb, double *res, double *resb) {
    for (int idx = n-1; idx > -1; --idx) {
        vb[idx] = vb[idx] + exp(v[idx])*resb[idx];
        resb[idx] = 0.0;
    }
}

/*
  Differentiation of vec_fill in reverse (adjoint) mode:
   gradient     of useful results: *res value
   with respect to varying inputs: *res value
   Plus diff mem management of: res:in
*/
void vec_fill_b(int n, double value, double *valueb, double *res, double *resb
) {
    for (int idx = n-1; idx > -1; --idx) {
        *valueb = *valueb + resb[idx];
        resb[idx] = 0.0;
    }
}

/*
  Differentiation of vec_sub in reverse (adjoint) mode:
   gradient     of useful results: *res *v1 *v2
   with respect to varying inputs: *res *v1 *v2
   Plus diff mem management of: res:in v1:in v2:in
*/
void vec_sub_b(int n, double *v1, double *v1b, double *v2, double *v2b, double
        *res, double *resb) {
    for (int idx = n-1; idx > -1; --idx) {
        v1b[idx] = v1b[idx] + resb[idx];
        v2b[idx] = v2b[idx] - resb[idx];
        resb[idx] = 0.0;
    }
}

/*
  Differentiation of vec_sum in reverse (adjoint) mode:
   gradient     of useful results: *x vec_sum
   with respect to varying inputs: *x
   Plus diff mem management of: x:in
*/
void vec_sum_b(int n, double *x, double *xb, double vec_sumb) {
    double res = 0;
    double resb = 0.0;
    double vec_sum;
    resb = vec_sumb;
    for (int i = n-1; i > -1; --i)
        xb[i] = xb[i] + resb;
}

/*
  Differentiation of vec_logsumexp_unfused in reverse (adjoint) mode:
   gradient     of useful results: alloc(*subv) alloc(*expv) alloc(*mxv)
                *v vec_logsumexp_unfused
   with respect to varying inputs: alloc(*subv) alloc(*expv) alloc(*mxv)
                *v
   RW status of diff variables: alloc(*subv):in-out alloc(*expv):in-out
                alloc(*mxv):in-out *v:incr vec_logsumexp_unfused:in-killed
   Plus diff mem management of: v:in
*/
void vec_logsumexp_unfused_b(int n, double *v, double *vb, double 
        vec_logsumexp_unfusedb) {
    double mx;
    double mxb;
    int ii1;
    double vec_logsumexp_unfused;
    mx = vec_max(n, v);
    double *mxv;
    double *mxvb;
    mxvb = (double *)malloc(n*sizeof(double));
    for (ii1 = 0; ii1 < n; ++ii1)
        mxvb[ii1] = 0.0;
    mxv = (double *)malloc(n*sizeof(double));
    vec_fill(n, mx, mxv);
    double *subv;
    double *subvb;
    subvb = (double *)malloc(n*sizeof(double));
    for (ii1 = 0; ii1 < n; ++ii1)
        subvb[ii1] = 0.0;
    subv = (double *)malloc(n*sizeof(double));
    vec_sub(n, v, mxv, subv);
    double *expv;
    double *expvb;
    expvb = (double *)malloc(n*sizeof(double));
    for (ii1 = 0; ii1 < n; ++ii1)
        expvb[ii1] = 0.0;
    expv = (double *)malloc(n*sizeof(double));
    vec_exp(n, subv, expv);
    double sum;
    double sumb;
    sum = vec_sum(n, expv);
    sumb = vec_logsumexp_unfusedb/sum;
    mxb = vec_logsumexp_unfusedb;
    vec_sum_b(n, expv, expvb, sumb);
    vec_exp_b(n, subv, subvb, expv, expvb);
    free(expv);
    free(expvb);
    vec_sub_b(n, v, vb, mxv, mxvb, subv, subvb);
    free(subv);
    free(subvb);
    vec_fill_b(n, mx, &mxb, mxv, mxvb);
    free(mxv);
    free(mxvb);
    vec_max_b(n, v, vb, mxb);
}

/*
  Differentiation of vec_dotsame in reverse (adjoint) mode:
   gradient     of useful results: *x vec_dotsame
   with respect to varying inputs: *x
   RW status of diff variables: *x:incr vec_dotsame:in-killed
   Plus diff mem management of: x:in
*/
void vec_dotsame_b(int n, double *x, double *xb, double vec_dotsameb) {
    double res = 0;
    double resb = 0.0;
    double vec_dotsame;
    resb = vec_dotsameb;
    for (int i = n-1; i > -1; --i)
        xb[i] = xb[i] + 2*x[i]*resb;
}
