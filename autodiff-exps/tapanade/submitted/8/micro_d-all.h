#include <math.h>
/*        Generated by TAPENADE     (INRIA, Ecuador team)
    Tapenade 3.13 (r6666M) -  1 Mar 2018 15:30
*/
/*
  Differentiation of vec_add in forward (tangent) mode:
   variations   of useful results: alloc(*res)
   with respect to varying inputs: *x
   RW status of diff variables: alloc(*res):out *x:in
   Plus diff mem management of: x:in
*/
double * vec_add_d(int n, double *x, double *xd, double *y, double **vec_add) 
{
    double *res;
    double *resd;
    resd = (double *)malloc(n*sizeof(double));
    res = (double *)malloc(n*sizeof(double));
    for (int i = 0; i < n; ++i) {
        resd[i] = xd[i];
        res[i] = x[i] + y[i];
    }
    *vec_add = res;
    return resd;
}
/*
  Differentiation of vec_elem_mult in forward (tangent) mode:
   variations   of useful results: alloc(*res)
   with respect to varying inputs: alloc(*res) *x *y
   RW status of diff variables: alloc(*res):in-out *x:in *y:in
   Plus diff mem management of: x:in y:in
*/
double * vec_elem_mult_d(int n, double *x, double *xd, double *y, double *yd, 
        double **vec_elem_mult) {
    double *res;
    double *resd;
    int ii1;
    resd = (double *)malloc(n*sizeof(double));
    for (ii1 = 0; ii1 < n; ++ii1)
        resd[ii1] = 0.0;
    res = (double *)malloc(n*sizeof(double));
    for (int i = 0; i < n; ++i) {
        resd[i] = xd[i]*y[i] + x[i]*yd[i];
        res[i] = x[i]*y[i];
    }
    *vec_elem_mult = res;
    return resd;
}
/*
  Differentiation of vec_scal_mult in forward (tangent) mode:
   variations   of useful results: alloc(*res)
   with respect to varying inputs: y
   RW status of diff variables: alloc(*res):out y:in
*/
double * vec_scal_mult_d(int n, double *x, double y, double yd, double **
        vec_scal_mult) {
    double *res;
    double *resd;
    resd = (double *)malloc(n*sizeof(double));
    res = (double *)malloc(n*sizeof(double));
    for (int i = 0; i < n; ++i) {
        resd[i] = x[i]*(yd*y+y*yd);
        res[i] = x[i]*y*y;
    }
    *vec_scal_mult = res;
    return resd;
}
/*
  Differentiation of vec_dot in forward (tangent) mode:
   variations   of useful results: vec_dot
   with respect to varying inputs: *x
   RW status of diff variables: *x:in vec_dot:out
   Plus diff mem management of: x:in
*/
double vec_dot_d(int n, double *x, double *xd, double *y, double *vec_dot) {
    double res = 0;
    double resd;
    resd = 0.0;
    for (int i = 0; i < n; ++i) {
        resd = resd + y[i]*xd[i];
        res += x[i]*y[i];
    }
    *vec_dot = res;
    return resd;
}
/*
  Differentiation of vec_max in forward (tangent) mode:
   variations   of useful results: vec_max
   with respect to varying inputs: *v
   Plus diff mem management of: v:in
*/
double vec_max_d(int n, double *v, double *vd, double *vec_max) {
    int x25608 = 0;
    for (int idx = 0; idx < n; ++idx) {
        int acc = x25608;
        int x25607;
        if (v[acc] > v[idx])
            x25607 = acc;
        else
            x25607 = idx;
        acc = x25607;
        x25608 = acc;
    }
    *vec_max = v[x25608];
    return vd[x25608];
}
/*
  Differentiation of vec_logsumexp in forward (tangent) mode:
   variations   of useful results: vec_logsumexp
   with respect to varying inputs: *v
   RW status of diff variables: *v:in vec_logsumexp:out
   Plus diff mem management of: v:in
*/
double vec_logsumexp_d(int n, double *v, double *vd, double *vec_logsumexp) {
    double mx;
    double mxd;
    mxd = vec_max_d(n, v, vd, &mx);
    double x25609 = 0;
    double x25609d;
    x25609d = 0.0;
    for (int idx = 0; idx < n; ++idx) {
        double acc = x25609;
        double accd = x25609d;
        accd = accd + (vd[idx]-mxd)*exp(v[idx]-mx);
        acc = acc + exp(v[idx] - mx);
        x25609d = accd;
        x25609 = acc;
    }
    *vec_logsumexp = log(x25609) + mx;
    return x25609d/x25609 + mxd;
}
/*
  Differentiation of vec_exp in forward (tangent) mode:
   variations   of useful results: *res
   with respect to varying inputs: *res *v
   Plus diff mem management of: res:in v:in
*/
void vec_exp_d(int n, double *v, double *vd, double *res, double *resd) {
    for (int idx = 0; idx < n; ++idx) {
        resd[idx] = vd[idx]*exp(v[idx]);
        res[idx] = exp(v[idx]);
    }
}

/*
  Differentiation of vec_fill in forward (tangent) mode:
   variations   of useful results: *res
   with respect to varying inputs: *res value
   Plus diff mem management of: res:in
*/
void vec_fill_d(int n, double value, double valued, double *res, double *resd)
{
    for (int idx = 0; idx < n; ++idx) {
        resd[idx] = valued;
        res[idx] = value;
    }
}

/*
  Differentiation of vec_sub in forward (tangent) mode:
   variations   of useful results: *res
   with respect to varying inputs: *res *v1 *v2
   Plus diff mem management of: res:in v1:in v2:in
*/
void vec_sub_d(int n, double *v1, double *v1d, double *v2, double *v2d, double
        *res, double *resd) {
    for (int idx = 0; idx < n; ++idx) {
        resd[idx] = v1d[idx] - v2d[idx];
        res[idx] = v1[idx] - v2[idx];
    }
}

/*
  Differentiation of vec_sum in forward (tangent) mode:
   variations   of useful results: vec_sum
   with respect to varying inputs: *x
   Plus diff mem management of: x:in
*/
double vec_sum_d(int n, double *x, double *xd, double *vec_sum) {
    double res = 0;
    double resd;
    resd = 0.0;
    for (int i = 0; i < n; ++i) {
        resd = resd + xd[i];
        res += x[i];
    }
    *vec_sum = res;
    return resd;
}

/*
  Differentiation of vec_logsumexp_unfused in forward (tangent) mode:
   variations   of useful results: alloc(*subv) alloc(*expv) alloc(*mxv)
                vec_logsumexp_unfused
   with respect to varying inputs: alloc(*subv) alloc(*expv) alloc(*mxv)
                *v
   RW status of diff variables: alloc(*subv):in-out alloc(*expv):in-out
                alloc(*mxv):in-out *v:in vec_logsumexp_unfused:out
   Plus diff mem management of: v:in
*/
double vec_logsumexp_unfused_d(int n, double *v, double *vd, double *
        vec_logsumexp_unfused) {
    double mx;
    double mxd;
    int ii1;
    mxd = vec_max_d(n, v, vd, &mx);
    double *mxv;
    double *mxvd;
    mxvd = (double *)malloc(n*sizeof(double));
    for (ii1 = 0; ii1 < n; ++ii1)
        mxvd[ii1] = 0.0;
    mxv = (double *)malloc(n*sizeof(double));
    vec_fill_d(n, mx, mxd, mxv, mxvd);
    double *subv;
    double *subvd;
    subvd = (double *)malloc(n*sizeof(double));
    for (ii1 = 0; ii1 < n; ++ii1)
        subvd[ii1] = 0.0;
    subv = (double *)malloc(n*sizeof(double));
    vec_sub_d(n, v, vd, mxv, mxvd, subv, subvd);
    free(mxvd);
    free(mxv);
    double *expv;
    double *expvd;
    expvd = (double *)malloc(n*sizeof(double));
    for (ii1 = 0; ii1 < n; ++ii1)
        expvd[ii1] = 0.0;
    expv = (double *)malloc(n*sizeof(double));
    vec_exp_d(n, subv, subvd, expv, expvd);
    free(subvd);
    free(subv);
    double sum;
    double sumd;
    sumd = vec_sum_d(n, expv, expvd, &sum);
    free(expvd);
    free(expv);
    *vec_logsumexp_unfused = log(sum) + mx;
    return sumd/sum + mxd;
}
