#include <math.h>
/*        Generated by TAPENADE     (INRIA, Ecuador team)
    Tapenade 3.13 (r6666M) -  1 Mar 2018 15:30
*/
/*
  Differentiation of vec_add in forward (tangent) mode:
   variations   of useful results: alloc(*res)
   with respect to varying inputs: *x
   RW status of diff variables: alloc(*res):out *x:in
   Plus diff mem management of: x:in
*/
double * vec_add_d(int n, double *x, double *xd, double *y, double **vec_add) 
{
    double *res;
    double *resd;
    resd = (double *)malloc(n*sizeof(double));
    res = (double *)malloc(n*sizeof(double));
    for (int i = 0; i < n; ++i) {
        resd[i] = xd[i];
        res[i] = x[i] + y[i];
    }
    *vec_add = res;
    return resd;
}
/*
  Differentiation of vec_elem_mult in forward (tangent) mode:
   variations   of useful results: alloc(*res)
   with respect to varying inputs: alloc(*res) *x *y
   RW status of diff variables: alloc(*res):in-out *x:in *y:in
   Plus diff mem management of: x:in y:in
*/
double * vec_elem_mult_d(int n, double *x, double *xd, double *y, double *yd, 
        double **vec_elem_mult) {
    double *res;
    double *resd;
    int ii1;
    resd = (double *)malloc(n*sizeof(double));
    for (ii1 = 0; ii1 < n; ++ii1)
        resd[ii1] = 0.0;
    res = (double *)malloc(n*sizeof(double));
    for (int i = 0; i < n; ++i) {
        resd[i] = xd[i]*y[i] + x[i]*yd[i];
        res[i] = x[i]*y[i];
    }
    *vec_elem_mult = res;
    return resd;
}
/*
  Differentiation of vec_scal_mult in forward (tangent) mode:
   variations   of useful results: alloc(*res)
   with respect to varying inputs: y
   RW status of diff variables: alloc(*res):out y:in
*/
double * vec_scal_mult_d(int n, double *x, double y, double yd, double **
        vec_scal_mult) {
    double *res;
    double *resd;
    resd = (double *)malloc(n*sizeof(double));
    res = (double *)malloc(n*sizeof(double));
    for (int i = 0; i < n; ++i) {
        resd[i] = x[i]*(yd*y+y*yd);
        res[i] = x[i]*y*y;
    }
    *vec_scal_mult = res;
    return resd;
}
/*
  Differentiation of vec_dot in forward (tangent) mode:
   variations   of useful results: vec_dot
   with respect to varying inputs: *x
   RW status of diff variables: *x:in vec_dot:out
   Plus diff mem management of: x:in
*/
double vec_dot_d(int n, double *x, double *xd, double *y, double *vec_dot) {
    double res = 0;
    double resd;
    resd = 0.0;
    for (int i = 0; i < n; ++i) {
        resd = resd + y[i]*xd[i];
        res += x[i]*y[i];
    }
    *vec_dot = res;
    return resd;
}
/*
  Differentiation of vec_max in forward (tangent) mode:
   variations   of useful results: vec_max
   with respect to varying inputs: *v
   Plus diff mem management of: v:in
*/
double vec_max_d(int n, double *v, double *vd, double *vec_max) {
    int x25608 = 0;
    for (int idx = 0; idx < n; ++idx) {
        int acc = x25608;
        int x25607;
        if (v[acc] > v[idx])
            x25607 = acc;
        else
            x25607 = idx;
        acc = x25607;
        x25608 = acc;
    }
    *vec_max = v[x25608];
    return vd[x25608];
}
/*
  Differentiation of vec_logsumexp in forward (tangent) mode:
   variations   of useful results: vec_logsumexp
   with respect to varying inputs: *v
   RW status of diff variables: *v:in vec_logsumexp:out
   Plus diff mem management of: v:in
*/
double vec_logsumexp_d(int n, double *v, double *vd, double *vec_logsumexp) {
    double mx;
    double mxd;
    mxd = vec_max_d(n, v, vd, &mx);
    double x25609 = 0;
    double x25609d;
    x25609d = 0.0;
    for (int idx = 0; idx < n; ++idx) {
        double acc = x25609;
        double accd = x25609d;
        accd = accd + (vd[idx]-mxd)*exp(v[idx]-mx);
        acc = acc + exp(v[idx] - mx);
        x25609d = accd;
        x25609 = acc;
    }
    *vec_logsumexp = log(x25609) + mx;
    return x25609d/x25609 + mxd;
}