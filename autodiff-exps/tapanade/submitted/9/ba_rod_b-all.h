#pragma once
/*        Generated by TAPENADE     (INRIA, Ecuador team)
    Tapenade 3.13 (r6666M) -  1 Mar 2018 15:30
*/
#include "../../ADFirstAidKit/adBuffer.h"
#include <stdlib.h>
#include <math.h>
#include "ba_rod.h"

/*
  Differentiation of sqsum in reverse (adjoint) mode:
   gradient     of useful results: *x sqsum
   with respect to varying inputs: *x
   Plus diff mem management of: x:in
*/
void sqsum_b(int n, double *x, double *xb, double sqsumb) {
    int i;
    double res;
    double resb;
    double sqsum;
    resb = sqsumb;
    for (i = n-1; i > -1; --i)
        xb[i] = xb[i] + 2*x[i]*resb;
}

/*
  Differentiation of cross in reverse (adjoint) mode:
   gradient     of useful results: *out *a *b
   with respect to varying inputs: *out *a *b
   Plus diff mem management of: out:in a:in b:in
*/
void cross_b0(double *a, double *ab, double *b, double *bb, double *out, 
        double *outb) {
    ab[0] = ab[0] + b[1]*outb[2];
    bb[1] = bb[1] + a[0]*outb[2];
    ab[1] = ab[1] - b[0]*outb[2];
    bb[0] = bb[0] - a[1]*outb[2];
    outb[2] = 0.0;
    ab[2] = ab[2] + b[0]*outb[1];
    bb[0] = bb[0] + a[2]*outb[1];
    ab[0] = ab[0] - b[2]*outb[1];
    bb[2] = bb[2] - a[0]*outb[1];
    outb[1] = 0.0;
    ab[1] = ab[1] + b[2]*outb[0];
    bb[2] = bb[2] + a[1]*outb[0];
    ab[2] = ab[2] - b[1]*outb[0];
    bb[1] = bb[1] - a[2]*outb[0];
    outb[0] = 0.0;
}

/*
  Differentiation of dot_prod in reverse (adjoint) mode:
   gradient     of useful results: *x *y dot_prod
   with respect to varying inputs: *x *y
   Plus diff mem management of: x:in y:in
*/
void dot_prod_b(int n, double *x, double *xb, double *y, double *yb, double 
        dot_prodb) {
    double res = 0;
    double resb = 0.0;
    double dot_prod;
    resb = dot_prodb;
    for (int i = n-1; i > -1; --i) {
        xb[i] = xb[i] + y[i]*resb;
        yb[i] = yb[i] + x[i]*resb;
    }
}

/*
  Differentiation of ba_rod_single in reverse (adjoint) mode:
   gradient     of useful results: alloc(*cross_) alloc(*w) *rot
                *rotatedPt *pt
   with respect to varying inputs: alloc(*cross_) alloc(*w) *rot
                *rotatedPt *pt
   Plus diff mem management of: rot:in rotatedPt:in pt:in
*/
void ba_rod_single_b(double *rot, double *rotb, double *pt, double *ptb, 
        double *rotatedPt, double *rotatedPtb) {
    int i;
    double sqtheta, theta, costheta, sintheta, theta_inverse, tmp;
    double sqthetab, thetab, costhetab, sinthetab, theta_inverseb, tmpb;
    double *w;
    double *wb;
    double result1;
    double result1b;
    int ii1;
    wb = (double *)malloc(sizeof(double)*3);
    for (ii1 = 0; ii1 < 3; ++ii1)
        wb[ii1] = 0.0;
    w = (double *)malloc(sizeof(double)*3);
    double *cross_;
    double *cross_b;
    cross_b = (double *)malloc(sizeof(double)*3);
    for (ii1 = 0; ii1 < 3; ++ii1)
        cross_b[ii1] = 0.0;
    cross_ = (double *)malloc(sizeof(double)*3);
    sqtheta = sqsum(3, rot);
    theta = sqrt(sqtheta);
    costheta = cos(theta);
    sintheta = sin(theta);
    theta_inverse = 1.0/theta;
    for (i = 0; i < 3; ++i)
        w[i] = rot[i]*theta_inverse;
    cross(w, pt, cross_);
    result1 = dot_prod(3, w, pt);
    tmp = result1*(1.-costheta);
    costhetab = 0.0;
    tmpb = 0.0;
    sinthetab = 0.0;
    for (i = 2; i > -1; --i) {
        ptb[i] = ptb[i] + costheta*rotatedPtb[i];
        costhetab = costhetab + pt[i]*rotatedPtb[i];
        cross_b[i] = cross_b[i] + sintheta*rotatedPtb[i];
        sinthetab = sinthetab + cross_[i]*rotatedPtb[i];
        wb[i] = wb[i] + tmp*rotatedPtb[i];
        tmpb = tmpb + w[i]*rotatedPtb[i];
        rotatedPtb[i] = 0.0;
    }
    result1b = (1.-costheta)*tmpb;
    costhetab = costhetab - result1*tmpb;
    dot_prod_b(3, w, wb, pt, ptb, result1b);
    cross_b0(w, wb, pt, ptb, cross_, cross_b);
    theta_inverseb = 0.0;
    for (i = 2; i > -1; --i) {
        rotb[i] = rotb[i] + theta_inverse*wb[i];
        theta_inverseb = theta_inverseb + rot[i]*wb[i];
        wb[i] = 0.0;
    }
    thetab = cos(theta)*sinthetab - sin(theta)*costhetab - theta_inverseb/(
        theta*theta);
    if (sqtheta == 0.0)
        sqthetab = 0.0;
    else
        sqthetab = thetab/(2.0*sqrt(sqtheta));
    sqsum_b(3, rot, rotb, sqthetab);
    free(cross_);
    free(cross_b);
    free(w);
    free(wb);
}

/*
  Differentiation of ba_rod_native in reverse (adjoint) mode:
   gradient     of useful results: alloc(*cross_) alloc(*w) **res
                *xs
   with respect to varying inputs: alloc(*cross_) alloc(*w) **res
                *xs
   RW status of diff variables: alloc(*cross_):in-out alloc(*w):in-out
                **res:in-out *xs:incr
   Plus diff mem management of: res:in *res:in xs:in
*/
void ba_rod_native_b(int d, double *xs, double *xsb, int n, double **res, 
        double **resb) {
    for (int idx = 0; idx < n; ++idx) {
        int offset = 11 + d*idx;
        ba_rod_single(xs, &xs[offset], res[idx]);
        pushinteger4(offset);
    }
    for (int idx = n-1; idx > -1; --idx) {
        int offset = 11 + d*idx;
        popinteger4(&offset);
        ba_rod_single_b(xs, xsb, &xs[offset], &xsb[offset], res[idx], resb[idx
                        ]);
    }
}
