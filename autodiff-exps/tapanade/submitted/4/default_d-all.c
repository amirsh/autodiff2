/*        Generated by TAPENADE     (INRIA, Ecuador team)
    Tapenade 3.13 (r6666M) -  1 Mar 2018 15:30
*/
#include <stdlib.h>
#include <math.h>

/*
  Differentiation of matrix_sum in forward (tangent) mode:
   variations   of useful results: matrix_sum
   with respect to varying inputs: **mat
   Plus diff mem management of: mat:in *mat:in
*/
// name of top routine:
// nmfMain
// dependent output variables:
// 
// independent variables:
// u
double matrix_sum_d(int m, int n, double **mat, double **matd, double *
        matrix_sum) {
    double res = 0;
    double resd;
    resd = 0.0;
    for (int i = 0; i < m; ++i)
        for (int j = 0; j < n; ++j) {
            resd = resd + matd[i][j];
            res += mat[i][j];
        }
    *matrix_sum = res;
    return resd;
}

/*
  Differentiation of matrix_add in forward (tangent) mode:
   variations   of useful results: **mat3
   with respect to varying inputs: **mat1 **mat2
   Plus diff mem management of: mat1:in *mat1:in mat2:in *mat2:in
                mat3:in *mat3:in
*/
void matrix_add_d(int m, int n, double **mat1, double **mat1d, double **mat2, 
        double **mat2d, double **mat3, double **mat3d) {
    **mat3d = 0.0;
    for (int i = 0; i < m; ++i)
        for (int j = 0; j < n; ++j) {
            mat3d[i][j] = mat1d[i][j] + mat2d[i][j];
            mat3[i][j] = mat1[i][j] + mat2[i][j];
        }
}

/*
  Differentiation of matrix_div in forward (tangent) mode:
   variations   of useful results: **mat3
   with respect to varying inputs: **mat2
   Plus diff mem management of: mat2:in *mat2:in mat3:in *mat3:in
*/
void matrix_div_d(int m, int n, double **mat1, double **mat2, double **mat2d, 
        double **mat3, double **mat3d) {
    **mat3d = 0.0;
    for (int i = 0; i < m; ++i)
        for (int j = 0; j < n; ++j) {
            mat3d[i][j] = -(mat1[i][j]*mat2d[i][j]/(mat2[i][j]*mat2[i][j]));
            mat3[i][j] = mat1[i][j]/mat2[i][j];
        }
}

/*
  Differentiation of matrix_log in forward (tangent) mode:
   variations   of useful results: **res
   with respect to varying inputs: **mat
   Plus diff mem management of: res:in *res:in mat:in *mat:in
*/
void matrix_log_d(int m, int n, double **mat, double **matd, double **res, 
        double **resd) {
    **resd = 0.0;
    for (int i = 0; i < m; ++i)
        for (int j = 0; j < n; ++j) {
            resd[i][j] = matd[i][j]/mat[i][j];
            res[i][j] = log(mat[i][j]);
        }
}

/*
  Differentiation of vector_out_prod in forward (tangent) mode:
   variations   of useful results: **res
   with respect to varying inputs: *v2
   Plus diff mem management of: res:in *res:in v2:in
*/
void vector_out_prod_d(int m, int n, double *v1, double *v2, double *v2d, 
        double **res, double **resd) {
    **resd = 0.0;
    for (int r = 0; r < m; ++r)
        for (int c = 0; c < n; ++c) {
            resd[r][c] = v1[r]*v2d[c];
            res[r][c] = v1[r]*v2[c];
        }
}

/*
  Differentiation of nmfMain in forward (tangent) mode:
   variations   of useful results: *alloc(*m3) *alloc(*m2) *alloc(*uv)
                *alloc(*m1) alloc(*elems4) alloc(*elems3) alloc(*elems2)
                alloc(*elems1) nmfMain
   with respect to varying inputs: *u
   RW status of diff variables: *alloc(*m3):out *alloc(*m2):out
                *alloc(*uv):out *alloc(*m1):out alloc(*elems4):out
                alloc(*elems3):out alloc(*elems2):out alloc(*elems1):out
                *u:in nmfMain:out
   Plus diff mem management of: alloc(*m3):in-out alloc(*m2):in-out
                alloc(*uv):in-out alloc(*m1):in-out u:in
*/
double nmfMain_d(int m, int n, double *u, double *ud, double *v, double **AA, 
        double *nmfMain) {
    double *elems1;
    double *elems1d;
    elems1d = (double *)malloc(sizeof(double)*m*n);
    elems1 = (double *)malloc(sizeof(double)*m*n);
    double *elems2;
    double *elems2d;
    elems2d = (double *)malloc(sizeof(double)*m*n);
    elems2 = (double *)malloc(sizeof(double)*m*n);
    double *elems3;
    double *elems3d;
    elems3d = (double *)malloc(sizeof(double)*m*n);
    elems3 = (double *)malloc(sizeof(double)*m*n);
    double *elems4;
    double *elems4d;
    elems4d = (double *)malloc(sizeof(double)*m*n);
    elems4 = (double *)malloc(sizeof(double)*m*n);
    double **m1;
    double **m1d;
    m1d = (double **)malloc(sizeof(double *)*n);
    m1 = (double **)malloc(sizeof(double *)*n);
    double **uv;
    double **uvd;
    uvd = (double **)malloc(sizeof(double *)*n);
    uv = (double **)malloc(sizeof(double *)*n);
    double **m2;
    double **m2d;
    m2d = (double **)malloc(sizeof(double *)*n);
    m2 = (double **)malloc(sizeof(double *)*n);
    double **m3;
    double **m3d;
    m3d = (double **)malloc(sizeof(double *)*n);
    m3 = (double **)malloc(sizeof(double *)*n);
    for (int i = 0; i < n; ++i) {
        if (elems1d)
            *elems1d = 0.0;
        m1d[i] = &elems1d[i*m];
        m1[i] = &elems1[i*m];
        if (elems2d)
            *elems2d = 0.0;
        uvd[i] = &elems2d[i*m];
        uv[i] = &elems2[i*m];
        if (elems3d)
            *elems3d = 0.0;
        m2d[i] = &elems3d[i*m];
        m2[i] = &elems3[i*m];
        if (elems4d)
            *elems4d = 0.0;
        m3d[i] = &elems4d[i*m];
        m3[i] = &elems4[i*m];
    }
    vector_out_prod_d(n, m, v, u, ud, uv, uvd);
    matrix_log_d(n, m, uv, uvd, m1, m1d);
    matrix_div_d(n, m, AA, uv, uvd, m2, m2d);
    matrix_add_d(n, m, m1, m1d, m2, m2d, m3, m3d);
    double res;
    double resd;
    resd = matrix_sum_d(n, m, m3, m3d, &res);
    free(elems1d);
    free(elems1);
    free(elems2d);
    free(elems2);
    free(elems3d);
    free(elems3);
    free(elems4d);
    free(elems4);
    free(m1d);
    free(m1);
    free(m2d);
    free(m2);
    free(m3d);
    free(m3);
    free(uvd);
    free(uv);
    *nmfMain = res;
    return resd;
}
