/*        Generated by TAPENADE     (INRIA, Ecuador team)
    Tapenade 3.13 (r6666M) -  1 Mar 2018 15:30
*/
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include "../../ADFirstAidKit/adBuffer.h"
#include "nmf_unfused.h"

/*
  Differentiation of matrix_sum in reverse (adjoint) mode:
   gradient     of useful results: matrix_sum **mat
   with respect to varying inputs: **mat
   Plus diff mem management of: mat:in *mat:in
*/
// name of top routine:
// nmfMain
// dependent output variables:
// 
// independent variables:
// u
void matrix_sum_b(int m, int n, double **mat, double **matb, double 
        matrix_sumb) {
    double res = 0;
    double resb = 0.0;
    double matrix_sum;
    resb = matrix_sumb;
    for (int i = m-1; i > -1; --i)
        for (int j = n-1; j > -1; --j)
            matb[i][j] = matb[i][j] + resb;
}

/*
  Differentiation of matrix_add in reverse (adjoint) mode:
   gradient     of useful results: **mat1 **mat2 **mat3
   with respect to varying inputs: **mat1 **mat2 **mat3
   Plus diff mem management of: mat1:in *mat1:in mat2:in *mat2:in
                mat3:in *mat3:in
*/
void matrix_add_b(int m, int n, double **mat1, double **mat1b, double **mat2, 
        double **mat2b, double **mat3, double **mat3b) {
    for (int i = m-1; i > -1; --i)
        for (int j = n-1; j > -1; --j) {
            mat1b[i][j] = mat1b[i][j] + mat3b[i][j];
            mat2b[i][j] = mat2b[i][j] + mat3b[i][j];
            mat3b[i][j] = 0.0;
        }
}

/*
  Differentiation of matrix_div in reverse (adjoint) mode:
   gradient     of useful results: **mat2 **mat3
   with respect to varying inputs: **mat2 **mat3
   Plus diff mem management of: mat2:in *mat2:in mat3:in *mat3:in
*/
void matrix_div_b(int m, int n, double **mat1, double **mat2, double **mat2b, 
        double **mat3, double **mat3b) {
    for (int i = m-1; i > -1; --i)
        for (int j = n-1; j > -1; --j) {
            mat2b[i][j] = mat2b[i][j] - mat1[i][j]*mat3b[i][j]/(mat2[i][j]*
                mat2[i][j]);
            mat3b[i][j] = 0.0;
        }
}

/*
  Differentiation of matrix_log in reverse (adjoint) mode:
   gradient     of useful results: **res **mat
   with respect to varying inputs: **res **mat
   Plus diff mem management of: res:in *res:in mat:in *mat:in
*/
void matrix_log_b(int m, int n, double **mat, double **matb, double **res, 
        double **resb) {
    for (int i = m-1; i > -1; --i)
        for (int j = n-1; j > -1; --j) {
            matb[i][j] = matb[i][j] + resb[i][j]/mat[i][j];
            resb[i][j] = 0.0;
        }
}

/*
  Differentiation of vector_out_prod in reverse (adjoint) mode:
   gradient     of useful results: **res *v2
   with respect to varying inputs: **res *v2
   Plus diff mem management of: res:in *res:in v2:in
*/
void vector_out_prod_b(int m, int n, double *v1, double *v2, double *v2b, 
        double **res, double **resb) {
    for (int r = m-1; r > -1; --r)
        for (int c = n-1; c > -1; --c) {
            v2b[c] = v2b[c] + v1[r]*resb[r][c];
            resb[r][c] = 0.0;
        }
}

/*
  Differentiation of nmfMain in reverse (adjoint) mode:
   gradient     of useful results: *alloc(*m3) *alloc(*m2) *alloc(*uv)
                *alloc(*m1) alloc(*elems4) alloc(*elems3) alloc(*elems2)
                alloc(*elems1) *u nmfMain
   with respect to varying inputs: *alloc(*m3) *alloc(*m2) *alloc(*uv)
                *alloc(*m1) alloc(*elems4) alloc(*elems3) alloc(*elems2)
                alloc(*elems1) *u
   RW status of diff variables: *alloc(*m3):in-out *alloc(*m2):in-out
                *alloc(*uv):in-out *alloc(*m1):in-out alloc(*elems4):in-out
                alloc(*elems3):in-out alloc(*elems2):in-out alloc(*elems1):in-out
                *u:incr nmfMain:in-killed
   Plus diff mem management of: alloc(*m3):in-out alloc(*m2):in-out
                alloc(*uv):in-out alloc(*m1):in-out u:in
*/
void nmfMain_b(int m, int n, double *u, double *ub, double *v, double **AA, 
        double nmfMainb) {
    double *elems1;
    double *elems1b;
    int ii1;
    double nmfMain;
    elems1b = (double *)malloc(sizeof(double)*m*n);
    for (ii1 = 0; ii1 < m*n; ++ii1)
        elems1b[ii1] = 0.0;
    elems1 = (double *)malloc(sizeof(double)*m*n);
    double *elems2;
    double *elems2b;
    elems2b = (double *)malloc(sizeof(double)*m*n);
    for (ii1 = 0; ii1 < m*n; ++ii1)
        elems2b[ii1] = 0.0;
    elems2 = (double *)malloc(sizeof(double)*m*n);
    double *elems3;
    double *elems3b;
    elems3b = (double *)malloc(sizeof(double)*m*n);
    for (ii1 = 0; ii1 < m*n; ++ii1)
        elems3b[ii1] = 0.0;
    elems3 = (double *)malloc(sizeof(double)*m*n);
    double *elems4;
    double *elems4b;
    elems4b = (double *)malloc(sizeof(double)*m*n);
    for (ii1 = 0; ii1 < m*n; ++ii1)
        elems4b[ii1] = 0.0;
    elems4 = (double *)malloc(sizeof(double)*m*n);
    double **m1;
    double **m1b;
    m1b = (double **)malloc(sizeof(double *)*n);
    for (ii1 = 0; ii1 < n; ++ii1)
        m1b[ii1] = NULL;
    m1 = (double **)malloc(sizeof(double *)*n);
    double **uv;
    double **uvb;
    uvb = (double **)malloc(sizeof(double *)*n);
    for (ii1 = 0; ii1 < n; ++ii1)
        uvb[ii1] = NULL;
    uv = (double **)malloc(sizeof(double *)*n);
    double **m2;
    double **m2b;
    m2b = (double **)malloc(sizeof(double *)*n);
    for (ii1 = 0; ii1 < n; ++ii1)
        m2b[ii1] = NULL;
    m2 = (double **)malloc(sizeof(double *)*n);
    double **m3;
    double **m3b;
    m3b = (double **)malloc(sizeof(double *)*n);
    for (ii1 = 0; ii1 < n; ++ii1)
        m3b[ii1] = NULL;
    m3 = (double **)malloc(sizeof(double *)*n);
    for (int i = 0; i < n; ++i) {
        m1b[i] = &elems1b[i*m];
        m1[i] = &elems1[i*m];
        uvb[i] = &elems2b[i*m];
        uv[i] = &elems2[i*m];
        m2b[i] = &elems3b[i*m];
        m2[i] = &elems3[i*m];
        m3b[i] = &elems4b[i*m];
        m3[i] = &elems4[i*m];
    }
    vector_out_prod(n, m, v, u, uv);
    matrix_log(n, m, uv, m1);
    matrix_div(n, m, AA, uv, m2);
    matrix_add(n, m, m1, m2, m3);
    double res;
    double resb;
    resb = nmfMainb;
    matrix_sum_b(n, m, m3, m3b, resb);
    matrix_add_b(n, m, m1, m1b, m2, m2b, m3, m3b);
    matrix_div_b(n, m, AA, uv, uvb, m2, m2b);
    matrix_log_b(n, m, uv, uvb, m1, m1b);
    vector_out_prod_b(n, m, v, u, ub, uv, uvb);
    free(m3);
    free(m3b);
    free(m2);
    free(m2b);
    free(uv);
    free(uvb);
    free(m1);
    free(m1b);
    free(elems4);
    free(elems4b);
    free(elems3);
    free(elems3b);
    free(elems2);
    free(elems2b);
    free(elems1);
    free(elems1b);
}
